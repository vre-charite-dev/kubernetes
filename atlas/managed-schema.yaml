apiVersion: v1
data:
  managed-schema:
    "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!--\n Licensed to
    the Apache Software Foundation (ASF) under one or more\n contributor license agreements.
    \ See the NOTICE file distributed with\n this work for additional information
    regarding copyright ownership.\n The ASF licenses this file to You under the Apache
    License, Version 2.0\n (the \"License\"); you may not use this file except in
    compliance with\n the License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n
    Unless required by applicable law or agreed to in writing, software\n distributed
    under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR
    CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific
    language governing permissions and\n limitations under the License.\n-->\n\n<!--\n\n
    This example schema is the recommended starting point for users.\n It should be
    kept correct and concise, usable out-of-the-box.\n\n\n For more information, on
    how to customize this file, please see\n http://lucene.apache.org/solr/guide/documents-fields-and-schema-design.html\n\n
    PERFORMANCE NOTE: this schema includes many optional features and should not\n
    be used for benchmarking.  To improve performance one could\n  - set stored=\"false\"
    for all fields possible (esp large fields) when you\n    only need to search on
    the field but don't need to return the original\n    value.\n  - set indexed=\"false\"
    if you don't need to search on the field, but only\n    return the field as a
    result of searching on other indexed fields.\n  - remove all unneeded copyField
    statements\n  - for best index size and searching performance, set \"index\" to
    false\n    for all general text fields, use copyField to copy them to the\n    catchall
    \"text\" field, and use that for searching.\n-->\n\n<schema name=\"default-config\"
    version=\"1.6\">\n    <!-- attribute \"name\" is the name of this schema and is
    only used for display purposes.\n       version=\"x.y\" is Solr's version number
    for the schema syntax and \n       semantics.  It should not normally be changed
    by applications.\n\n       1.0: multiValued attribute did not exist, all fields
    are multiValued \n            by nature\n       1.1: multiValued attribute introduced,
    false by default \n       1.2: omitTermFreqAndPositions attribute introduced,
    true by default \n            except for text fields.\n       1.3: removed optional
    field compress feature\n       1.4: autoGeneratePhraseQueries attribute introduced
    to drive QueryParser\n            behavior when a single string produces multiple
    tokens.  Defaults \n            to off for version >= 1.4\n       1.5: omitNorms
    defaults to true for primitive field types \n            (int, float, boolean,
    string...)\n       1.6: useDocValuesAsStored defaults to true.\n    -->\n\n    <!--
    Valid attributes for fields:\n     name: mandatory - the name for the field\n
    \    type: mandatory - the name of a field type from the \n       fieldTypes section\n
    \    indexed: true if this field should be indexed (searchable or sortable)\n
    \    stored: true if this field should be retrievable\n     docValues: true if
    this field should have doc values. Doc Values is\n       recommended (required,
    if you are using *Point fields) for faceting,\n       grouping, sorting and function
    queries. Doc Values will make the index\n       faster to load, more NRT-friendly
    and more memory-efficient. \n       They are currently only supported by StrField,
    UUIDField, all \n       *PointFields, and depending on the field type, they might
    require\n       the field to be single-valued, be required or have a default value\n
    \      (check the documentation of the field type you're interested in for\n       more
    information)\n     multiValued: true if this field may contain multiple values
    per document\n     omitNorms: (expert) set to true to omit the norms associated
    with\n       this field (this disables length normalization and index-time\n       boosting
    for the field, and saves some memory).  Only full-text\n       fields or fields
    that need an index-time boost need norms.\n       Norms are omitted for primitive
    (non-analyzed) types by default.\n     termVectors: [false] set to true to store
    the term vector for a\n       given field.\n       When using MoreLikeThis, fields
    used for similarity should be\n       stored for best performance.\n     termPositions:
    Store position information with the term vector.  \n       This will increase
    storage costs.\n     termOffsets: Store offset information with the term vector.
    This \n       will increase storage costs.\n     required: The field is required.
    \ It will throw an error if the\n       value does not exist\n     default: a
    value that should be used if no value is specified\n       when adding a document.\n
    \   -->\n\n    <!-- field names should consist of alphanumeric or underscore characters
    only and\n      not start with a digit.  This is not currently strictly enforced,\n
    \     but other field names will not have first class support from all components\n
    \     and back compatibility is not guaranteed.  Names with both leading and\n
    \     trailing underscores (e.g. _version_) are reserved.\n    -->\n\n    <!--
    In this _default configset, only four fields are pre-declared:\n         id, _version_,
    and _text_ and _root_. All other fields will be type guessed and added via the\n
    \        \"add-unknown-fields-to-the-schema\" update request processor chain declared
    in solrconfig.xml.\n         \n         Note that many dynamic fields are also
    defined - you can use them to specify a \n         field's type via field naming
    conventions - see below.\n  \n         WARNING: The _text_ catch-all field will
    significantly increase your index size.\n         If you don't need it, consider
    removing it and the corresponding copyField directive.\n    -->\n\n    <field
    name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\"
    multiValued=\"false\" />\n    <!-- docValues are enabled by default for long type
    so we don't need to index the version field  -->\n    <field name=\"_version_\"
    type=\"plong\" indexed=\"false\" stored=\"false\"/>\n    <field name=\"_root_\"
    type=\"string\" indexed=\"true\" stored=\"false\" docValues=\"false\" />\n    <field
    name=\"_text_\" type=\"text_general\" indexed=\"true\" stored=\"false\" multiValued=\"true\"/>\n\n
    \   <!-- This can be enabled, in case the client does not know what fields may
    be searched. It isn't enabled by default\n         because it's very expensive
    to index everything twice. -->\n    <!-- <copyField source=\"*\" dest=\"_text_\"/>
    -->\n\n    <!-- Dynamic field definitions allow using convention over configuration\n
    \      for fields via the specification of patterns to match field names.\n       EXAMPLE:
    \ name=\"*_i\" will match any field ending in _i (like myid_i, z_i)\n       RESTRICTION:
    the glob-like pattern in the name attribute must have a \"*\" only at the start
    or the end.  -->\n   \n    <dynamicField name=\"*_i\"  type=\"pint\"    indexed=\"true\"
    \ stored=\"true\"/>\n    <dynamicField name=\"*_is\" type=\"pints\"    indexed=\"true\"
    \ stored=\"true\"/>\n    <dynamicField name=\"*_s\"  type=\"string\"  indexed=\"true\"
    \ stored=\"true\" />\n    <dynamicField name=\"*_ss\" type=\"strings\"  indexed=\"true\"
    \ stored=\"true\"/>\n    <dynamicField name=\"*_l\"  type=\"plong\"   indexed=\"true\"
    \ stored=\"true\"/>\n    <dynamicField name=\"*_ls\" type=\"plongs\"   indexed=\"true\"
    \ stored=\"true\"/>\n    <dynamicField name=\"*_t\" type=\"text_general\" indexed=\"true\"
    stored=\"true\" multiValued=\"false\"/>\n    <dynamicField name=\"*_txt\" type=\"text_general\"
    indexed=\"true\" stored=\"true\"/>\n    <dynamicField name=\"*_b\"  type=\"boolean\"
    indexed=\"true\" stored=\"true\"/>\n    <dynamicField name=\"*_bs\" type=\"booleans\"
    indexed=\"true\" stored=\"true\"/>\n    <dynamicField name=\"*_f\"  type=\"pfloat\"
    \ indexed=\"true\"  stored=\"true\"/>\n    <dynamicField name=\"*_fs\" type=\"pfloats\"
    \ indexed=\"true\"  stored=\"true\"/>\n    <dynamicField name=\"*_d\"  type=\"pdouble\"
    indexed=\"true\"  stored=\"true\"/>\n    <dynamicField name=\"*_ds\" type=\"pdoubles\"
    indexed=\"true\"  stored=\"true\"/>\n    <dynamicField name=\"random_*\" type=\"random\"/>\n\n
    \   <!-- Type used for data-driven schema, to add a string copy for each text
    field -->\n    <dynamicField name=\"*_str\" type=\"strings\" stored=\"false\"
    docValues=\"true\" indexed=\"false\" useDocValuesAsStored=\"false\"/>\n\n    <dynamicField
    name=\"*_dt\"  type=\"pdate\"    indexed=\"true\"  stored=\"true\"/>\n    <dynamicField
    name=\"*_dts\" type=\"pdate\"    indexed=\"true\"  stored=\"true\" multiValued=\"true\"/>\n
    \   <dynamicField name=\"*_p\"  type=\"location\" indexed=\"true\" stored=\"true\"/>\n
    \   <dynamicField name=\"*_srpt\"  type=\"location_rpt\" indexed=\"true\" stored=\"true\"/>\n
    \   \n    <!-- payloaded dynamic fields -->\n    <dynamicField name=\"*_dpf\"
    type=\"delimited_payloads_float\" indexed=\"true\"  stored=\"true\"/>\n    <dynamicField
    name=\"*_dpi\" type=\"delimited_payloads_int\" indexed=\"true\"  stored=\"true\"/>\n
    \   <dynamicField name=\"*_dps\" type=\"delimited_payloads_string\" indexed=\"true\"
    \ stored=\"true\"/>\n\n    <dynamicField name=\"attr_*\" type=\"text_general\"
    indexed=\"true\" stored=\"true\" multiValued=\"true\"/>\n\n    <!-- Field to use
    to determine and enforce document uniqueness.\n      Unless this field is marked
    with required=\"false\", it will be a required field\n    -->\n    <uniqueKey>id</uniqueKey>\n\n
    \   <!-- copyField commands copy one field to another at the time a document\n
    \      is added to the index.  It's used either to index the same field differently,\n
    \      or to add multiple fields to the same field for easier/faster searching.\n\n
    \   <copyField source=\"sourceFieldName\" dest=\"destinationFieldName\"/>\n    -->\n\n
    \   <!-- field type definitions. The \"name\" attribute is\n       just a label
    to be used by field definitions.  The \"class\"\n       attribute and any other
    attributes determine the real\n       behavior of the fieldType.\n         Class
    names starting with \"solr\" refer to java classes in a\n       standard package
    such as org.apache.solr.analysis\n    -->\n\n    <!-- sortMissingLast and sortMissingFirst
    attributes are optional attributes are\n         currently supported on types
    that are sorted internally as strings\n         and on numeric types.\n       This
    includes \"string\", \"boolean\", \"pint\", \"pfloat\", \"plong\", \"pdate\",
    \"pdouble\".\n       - If sortMissingLast=\"true\", then a sort on this field
    will cause documents\n         without the field to come after documents with
    the field,\n         regardless of the requested sort order (asc or desc).\n       -
    If sortMissingFirst=\"true\", then a sort on this field will cause documents\n
    \        without the field to come before documents with the field,\n         regardless
    of the requested sort order.\n       - If sortMissingLast=\"false\" and sortMissingFirst=\"false\"
    (the default),\n         then default lucene sorting will be used which places
    docs without the\n         field first in an ascending sort and last in a descending
    sort.\n    -->\n\n    <!-- The StrField type is not analyzed, but indexed/stored
    verbatim. -->\n    <fieldType name=\"string\" class=\"solr.StrField\" sortMissingLast=\"true\"
    docValues=\"true\" />\n    <fieldType name=\"strings\" class=\"solr.StrField\"
    sortMissingLast=\"true\" multiValued=\"true\" docValues=\"true\" />\n\n    <!--
    boolean type: \"true\" or \"false\" -->\n    <fieldType name=\"boolean\" class=\"solr.BoolField\"
    sortMissingLast=\"true\"/>\n    <fieldType name=\"booleans\" class=\"solr.BoolField\"
    sortMissingLast=\"true\" multiValued=\"true\"/>\n\n    <!--\n      Numeric field
    types that index values using KD-trees.\n      Point fields don't support FieldCache,
    so they must have docValues=\"true\" if needed for sorting, faceting, functions,
    etc.\n    -->\n    <fieldType name=\"pint\" class=\"solr.IntPointField\" docValues=\"true\"/>\n
    \   <fieldType name=\"pfloat\" class=\"solr.FloatPointField\" docValues=\"true\"/>\n
    \   <fieldType name=\"plong\" class=\"solr.LongPointField\" docValues=\"true\"/>\n
    \   <fieldType name=\"pdouble\" class=\"solr.DoublePointField\" docValues=\"true\"/>\n
    \   \n    <fieldType name=\"pints\" class=\"solr.IntPointField\" docValues=\"true\"
    multiValued=\"true\"/>\n    <fieldType name=\"pfloats\" class=\"solr.FloatPointField\"
    docValues=\"true\" multiValued=\"true\"/>\n    <fieldType name=\"plongs\" class=\"solr.LongPointField\"
    docValues=\"true\" multiValued=\"true\"/>\n    <fieldType name=\"pdoubles\" class=\"solr.DoublePointField\"
    docValues=\"true\" multiValued=\"true\"/>\n    <fieldType name=\"random\" class=\"solr.RandomSortField\"
    indexed=\"true\"/>\n\n\n    <!-- The format for this date field is of the form
    1995-12-31T23:59:59Z, and\n         is a more restricted form of the canonical
    representation of dateTime\n         http://www.w3.org/TR/xmlschema-2/#dateTime
    \   \n         The trailing \"Z\" designates UTC time and is mandatory.\n         Optional
    fractional seconds are allowed: 1995-12-31T23:59:59.999Z\n         All other components
    are mandatory.\n\n         Expressions can also be used to denote calculations
    that should be\n         performed relative to \"NOW\" to determine the value,
    ie...\n\n               NOW/HOUR\n                  ... Round to the start of
    the current hour\n               NOW-1DAY\n                  ... Exactly 1 day
    prior to now\n               NOW/DAY+6MONTHS+3DAYS\n                  ... 6 months
    and 3 days in the future from the start of\n                      the current
    day\n                      \n      -->\n    <!-- KD-tree versions of date fields
    -->\n    <fieldType name=\"pdate\" class=\"solr.DatePointField\" docValues=\"true\"/>\n
    \   <fieldType name=\"pdates\" class=\"solr.DatePointField\" docValues=\"true\"
    multiValued=\"true\"/>\n    \n    <!--Binary data type. The data should be sent/retrieved
    in as Base64 encoded Strings -->\n    <fieldType name=\"binary\" class=\"solr.BinaryField\"/>\n\n
    \   <!-- solr.TextField allows the specification of custom text analyzers\n         specified
    as a tokenizer and a list of token filters. Different\n         analyzers may
    be specified for indexing and querying.\n\n         The optional positionIncrementGap
    puts space between multiple fields of\n         this type on the same document,
    with the purpose of preventing false phrase\n         matching across fields.\n\n
    \        For more info on customizing your analyzer chain, please see\n         http://lucene.apache.org/solr/guide/understanding-analyzers-tokenizers-and-filters.html#understanding-analyzers-tokenizers-and-filters\n
    \    -->\n\n    <!-- One can also specify an existing Analyzer class that has
    a\n         default constructor via the class attribute on the analyzer element.\n
    \        Example:\n    <fieldType name=\"text_greek\" class=\"solr.TextField\">\n
    \     <analyzer class=\"org.apache.lucene.analysis.el.GreekAnalyzer\"/>\n    </fieldType>\n
    \   -->\n\n    <!-- A text field that only splits on whitespace for exact matching
    of words -->\n    <dynamicField name=\"*_ws\" type=\"text_ws\"  indexed=\"true\"
    \ stored=\"true\"/>\n    <fieldType name=\"text_ws\" class=\"solr.TextField\"
    positionIncrementGap=\"100\">\n      <analyzer>\n        <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n
    \     </analyzer>\n    </fieldType>\n\n    <!-- A general text field that has
    reasonable, generic\n         cross-language defaults: it tokenizes with StandardTokenizer,\n\t
    \      removes stop words from case-insensitive \"stopwords.txt\"\n\t       (empty
    by default), and down cases.  At query time only, it\n\t       also applies synonyms.\n\t
    \ -->\n    <fieldType name=\"text_general\" class=\"solr.TextField\" positionIncrementGap=\"100\"
    multiValued=\"false\" />\n\n    \n    <!-- SortableTextField generaly functions
    exactly like TextField,\n         except that it supports, and by default uses,
    docValues for sorting (or faceting)\n         on the first 1024 characters of
    the original field values (which is configurable).\n         \n         This makes
    it a bit more useful then TextField in many situations, but the trade-off\n         is
    that it takes up more space on disk; which is why it's not used in place of TextField\n
    \        for every fieldType in this _default schema.\n\t  -->\n    <dynamicField
    name=\"*_t_sort\" type=\"text_gen_sort\" indexed=\"true\" stored=\"true\" multiValued=\"false\"/>\n
    \   <dynamicField name=\"*_txt_sort\" type=\"text_gen_sort\" indexed=\"true\"
    stored=\"true\"/>\n    <fieldType name=\"text_gen_sort\" class=\"solr.SortableTextField\"
    positionIncrementGap=\"100\" multiValued=\"true\">\n      <analyzer type=\"index\">\n
    \       <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"stopwords.txt\" />\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n      </analyzer>\n      <analyzer
    type=\"query\">\n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"stopwords.txt\"
    />\n        <filter class=\"solr.SynonymGraphFilterFactory\" synonyms=\"synonyms.txt\"
    ignoreCase=\"true\" expand=\"true\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \     </analyzer>\n    </fieldType>\n\n    <!-- A text field with defaults appropriate
    for English: it tokenizes with StandardTokenizer,\n         removes English stop
    words (lang/stopwords_en.txt), down cases, protects words from protwords.txt,
    and\n         finally applies Porter's stemming.  The query time analyzer also
    applies synonyms from synonyms.txt. -->\n    <dynamicField name=\"*_txt_en\" type=\"text_en\"
    \ indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_en\" class=\"solr.TextField\"
    positionIncrementGap=\"100\">\n      <analyzer type=\"index\">\n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <!-- in this example, we will
    only use synonyms at query time\n        <filter class=\"solr.SynonymGraphFilterFactory\"
    synonyms=\"index_synonyms.txt\" ignoreCase=\"true\" expand=\"false\"/>\n        <filter
    class=\"solr.FlattenGraphFilterFactory\"/>\n        -->\n        <!-- Case insensitive
    stop word removal.\n        -->\n        <filter class=\"solr.StopFilterFactory\"\n
    \               ignoreCase=\"true\"\n                words=\"lang/stopwords_en.txt\"\n
    \           />\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter
    class=\"solr.EnglishPossessiveFilterFactory\"/>\n        <filter class=\"solr.KeywordMarkerFilterFactory\"
    protected=\"protwords.txt\"/>\n        <!-- Optionally you may want to use this
    less aggressive stemmer instead of PorterStemFilterFactory:\n        <filter class=\"solr.EnglishMinimalStemFilterFactory\"/>\n\t
    \     -->\n        <filter class=\"solr.PorterStemFilterFactory\"/>\n      </analyzer>\n
    \     <analyzer type=\"query\">\n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <filter class=\"solr.SynonymGraphFilterFactory\" synonyms=\"synonyms.txt\"
    ignoreCase=\"true\" expand=\"true\"/>\n        <filter class=\"solr.StopFilterFactory\"\n
    \               ignoreCase=\"true\"\n                words=\"lang/stopwords_en.txt\"\n
    \       />\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter
    class=\"solr.EnglishPossessiveFilterFactory\"/>\n        <filter class=\"solr.KeywordMarkerFilterFactory\"
    protected=\"protwords.txt\"/>\n        <!-- Optionally you may want to use this
    less aggressive stemmer instead of PorterStemFilterFactory:\n        <filter class=\"solr.EnglishMinimalStemFilterFactory\"/>\n\t
    \     -->\n        <filter class=\"solr.PorterStemFilterFactory\"/>\n      </analyzer>\n
    \   </fieldType>\n\n    <!-- A text field with defaults appropriate for English,
    plus\n         aggressive word-splitting and autophrase features enabled.\n         This
    field is just like text_en, except it adds\n         WordDelimiterGraphFilter
    to enable splitting and matching of\n         words on case-change, alpha numeric
    boundaries, and\n         non-alphanumeric chars.  This means certain compound
    word\n         cases will work, for example query \"wi fi\" will match\n         document
    \"WiFi\" or \"wi-fi\".\n    -->\n    <dynamicField name=\"*_txt_en_split\" type=\"text_en_splitting\"
    \ indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_en_splitting\"
    class=\"solr.TextField\" positionIncrementGap=\"100\" autoGeneratePhraseQueries=\"true\">\n
    \     <analyzer type=\"index\">\n        <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n
    \       <!-- in this example, we will only use synonyms at query time\n        <filter
    class=\"solr.SynonymGraphFilterFactory\" synonyms=\"index_synonyms.txt\" ignoreCase=\"true\"
    expand=\"false\"/>\n        -->\n        <!-- Case insensitive stop word removal.\n
    \       -->\n        <filter class=\"solr.StopFilterFactory\"\n                ignoreCase=\"true\"\n
    \               words=\"lang/stopwords_en.txt\"\n        />\n        <filter class=\"solr.WordDelimiterGraphFilterFactory\"
    generateWordParts=\"1\" generateNumberParts=\"1\" catenateWords=\"1\" catenateNumbers=\"1\"
    catenateAll=\"0\" splitOnCaseChange=\"1\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.KeywordMarkerFilterFactory\" protected=\"protwords.txt\"/>\n
    \       <filter class=\"solr.PorterStemFilterFactory\"/>\n        <filter class=\"solr.FlattenGraphFilterFactory\"
    />\n      </analyzer>\n      <analyzer type=\"query\">\n        <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n
    \       <filter class=\"solr.SynonymGraphFilterFactory\" synonyms=\"synonyms.txt\"
    ignoreCase=\"true\" expand=\"true\"/>\n        <filter class=\"solr.StopFilterFactory\"\n
    \               ignoreCase=\"true\"\n                words=\"lang/stopwords_en.txt\"\n
    \       />\n        <filter class=\"solr.WordDelimiterGraphFilterFactory\" generateWordParts=\"1\"
    generateNumberParts=\"1\" catenateWords=\"0\" catenateNumbers=\"0\" catenateAll=\"0\"
    splitOnCaseChange=\"1\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.KeywordMarkerFilterFactory\" protected=\"protwords.txt\"/>\n
    \       <filter class=\"solr.PorterStemFilterFactory\"/>\n      </analyzer>\n
    \   </fieldType>\n\n    <!-- Less flexible matching, but less false matches.  Probably
    not ideal for product names,\n         but may be good for SKUs.  Can insert dashes
    in the wrong place and still match. -->\n    <dynamicField name=\"*_txt_en_split_tight\"
    type=\"text_en_splitting_tight\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_en_splitting_tight\" class=\"solr.TextField\" positionIncrementGap=\"100\"
    autoGeneratePhraseQueries=\"true\">\n      <analyzer type=\"index\">\n        <tokenizer
    class=\"solr.WhitespaceTokenizerFactory\"/>\n        <filter class=\"solr.SynonymGraphFilterFactory\"
    synonyms=\"synonyms.txt\" ignoreCase=\"true\" expand=\"false\"/>\n        <filter
    class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_en.txt\"/>\n
    \       <filter class=\"solr.WordDelimiterGraphFilterFactory\" generateWordParts=\"0\"
    generateNumberParts=\"0\" catenateWords=\"1\" catenateNumbers=\"1\" catenateAll=\"0\"/>\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.KeywordMarkerFilterFactory\"
    protected=\"protwords.txt\"/>\n        <filter class=\"solr.EnglishMinimalStemFilterFactory\"/>\n
    \       <!-- this filter can remove any duplicate tokens that appear at the same
    position - sometimes\n             possible with WordDelimiterGraphFilter in conjuncton
    with stemming. -->\n        <filter class=\"solr.RemoveDuplicatesTokenFilterFactory\"/>\n
    \       <filter class=\"solr.FlattenGraphFilterFactory\" />\n      </analyzer>\n
    \     <analyzer type=\"query\">\n        <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n
    \       <filter class=\"solr.SynonymGraphFilterFactory\" synonyms=\"synonyms.txt\"
    ignoreCase=\"true\" expand=\"false\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_en.txt\"/>\n        <filter class=\"solr.WordDelimiterGraphFilterFactory\"
    generateWordParts=\"0\" generateNumberParts=\"0\" catenateWords=\"1\" catenateNumbers=\"1\"
    catenateAll=\"0\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.KeywordMarkerFilterFactory\" protected=\"protwords.txt\"/>\n
    \       <filter class=\"solr.EnglishMinimalStemFilterFactory\"/>\n        <!--
    this filter can remove any duplicate tokens that appear at the same position -
    sometimes\n             possible with WordDelimiterGraphFilter in conjuncton with
    stemming. -->\n        <filter class=\"solr.RemoveDuplicatesTokenFilterFactory\"/>\n
    \     </analyzer>\n    </fieldType>\n\n    <!-- Just like text_general except
    it reverses the characters of\n\t       each token, to enable more efficient leading
    wildcard queries.\n    -->\n    <dynamicField name=\"*_txt_rev\" type=\"text_general_rev\"
    \ indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_general_rev\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer type=\"index\">\n
    \       <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"stopwords.txt\" />\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.ReversedWildcardFilterFactory\"
    withOriginal=\"true\"\n                maxPosAsterisk=\"3\" maxPosQuestion=\"2\"
    maxFractionAsterisk=\"0.33\"/>\n      </analyzer>\n      <analyzer type=\"query\">\n
    \       <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.SynonymGraphFilterFactory\" synonyms=\"synonyms.txt\" ignoreCase=\"true\"
    expand=\"true\"/>\n        <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\"
    words=\"stopwords.txt\" />\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \     </analyzer>\n    </fieldType>\n\n    <dynamicField name=\"*_phon_en\" type=\"phonetic_en\"
    \ indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"phonetic_en\" stored=\"false\"
    indexed=\"true\" class=\"solr.TextField\" >\n      <analyzer>\n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <filter class=\"solr.DoubleMetaphoneFilterFactory\"
    inject=\"false\"/>\n      </analyzer>\n    </fieldType>\n\n    <!-- lowercases
    the entire field value, keeping it as a single token.  -->\n    <dynamicField
    name=\"*_s_lower\" type=\"lowercase\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"lowercase\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>\n
    \       <tokenizer class=\"solr.KeywordTokenizerFactory\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"
    />\n      </analyzer>\n    </fieldType>\n\n    <!-- \n      Example of using PathHierarchyTokenizerFactory
    at index time, so\n      queries for paths match documents at that path, or in
    descendent paths\n    -->\n    <dynamicField name=\"*_descendent_path\" type=\"descendent_path\"
    \ indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"descendent_path\"
    class=\"solr.TextField\">\n      <analyzer type=\"index\">\n        <tokenizer
    class=\"solr.PathHierarchyTokenizerFactory\" delimiter=\"/\" />\n      </analyzer>\n
    \     <analyzer type=\"query\">\n        <tokenizer class=\"solr.KeywordTokenizerFactory\"
    />\n      </analyzer>\n    </fieldType>\n\n    <!--\n      Example of using PathHierarchyTokenizerFactory
    at query time, so\n      queries for paths match documents at that path, or in
    ancestor paths\n    -->\n    <dynamicField name=\"*_ancestor_path\" type=\"ancestor_path\"
    \ indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"ancestor_path\" class=\"solr.TextField\">\n
    \     <analyzer type=\"index\">\n        <tokenizer class=\"solr.KeywordTokenizerFactory\"
    />\n      </analyzer>\n      <analyzer type=\"query\">\n        <tokenizer class=\"solr.PathHierarchyTokenizerFactory\"
    delimiter=\"/\" />\n      </analyzer>\n    </fieldType>\n\n    <!-- This point
    type indexes the coordinates as separate fields (subFields)\n      If subFieldType
    is defined, it references a type, and a dynamic field\n      definition is created
    matching *___<typename>.  Alternately, if \n      subFieldSuffix is defined, that
    is used to create the subFields.\n      Example: if subFieldType=\"double\", then
    the coordinates would be\n        indexed in fields myloc_0___double,myloc_1___double.\n
    \     Example: if subFieldSuffix=\"_d\" then the coordinates would be indexed\n
    \       in fields myloc_0_d,myloc_1_d\n      The subFields are an implementation
    detail of the fieldType, and end\n      users normally should not need to know
    about them.\n     -->\n    <dynamicField name=\"*_point\" type=\"point\"  indexed=\"true\"
    \ stored=\"true\"/>\n    <fieldType name=\"point\" class=\"solr.PointType\" dimension=\"2\"
    subFieldSuffix=\"_d\"/>\n\n    <!-- A specialized field for geospatial search
    filters and distance sorting. -->\n    <fieldType name=\"location\" class=\"solr.LatLonPointSpatialField\"
    docValues=\"true\"/>\n\n    <!-- A geospatial field type that supports multiValued
    and polygon shapes.\n      For more information about this and other spatial fields
    see:\n      http://lucene.apache.org/solr/guide/spatial-search.html\n    -->\n
    \   <fieldType name=\"location_rpt\" class=\"solr.SpatialRecursivePrefixTreeFieldType\"\n
    \              geo=\"true\" distErrPct=\"0.025\" maxDistErr=\"0.001\" distanceUnits=\"kilometers\"
    />\n\n    <!-- Payloaded field types -->\n    <fieldType name=\"delimited_payloads_float\"
    stored=\"false\" indexed=\"true\" class=\"solr.TextField\">\n      <analyzer>\n
    \       <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n        <filter
    class=\"solr.DelimitedPayloadTokenFilterFactory\" encoder=\"float\"/>\n      </analyzer>\n
    \   </fieldType>\n    <fieldType name=\"delimited_payloads_int\" stored=\"false\"
    indexed=\"true\" class=\"solr.TextField\">\n      <analyzer>\n        <tokenizer
    class=\"solr.WhitespaceTokenizerFactory\"/>\n        <filter class=\"solr.DelimitedPayloadTokenFilterFactory\"
    encoder=\"integer\"/>\n      </analyzer>\n    </fieldType>\n    <fieldType name=\"delimited_payloads_string\"
    stored=\"false\" indexed=\"true\" class=\"solr.TextField\">\n      <analyzer>\n
    \       <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n        <filter
    class=\"solr.DelimitedPayloadTokenFilterFactory\" encoder=\"identity\"/>\n      </analyzer>\n
    \   </fieldType>\n\n    <!-- some examples for different languages (generally
    ordered by ISO code) -->\n\n    <!-- Arabic -->\n    <dynamicField name=\"*_txt_ar\"
    type=\"text_ar\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_ar\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <!-- for any non-arabic -->\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_ar.txt\" />\n        <!-- normalizes
    ﻯ to ﻱ, etc -->\n        <filter class=\"solr.ArabicNormalizationFilterFactory\"/>\n
    \       <filter class=\"solr.ArabicStemFilterFactory\"/>\n      </analyzer>\n
    \   </fieldType>\n\n    <!-- Bulgarian -->\n    <dynamicField name=\"*_txt_bg\"
    type=\"text_bg\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_bg\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/> \n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_bg.txt\"
    /> \n        <filter class=\"solr.BulgarianStemFilterFactory\"/>       \n      </analyzer>\n
    \   </fieldType>\n    \n    <!-- Catalan -->\n    <dynamicField name=\"*_txt_ca\"
    type=\"text_ca\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_ca\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <!-- removes l', etc -->\n
    \       <filter class=\"solr.ElisionFilterFactory\" ignoreCase=\"true\" articles=\"lang/contractions_ca.txt\"/>\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_ca.txt\" />\n        <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Catalan\"/>       \n      </analyzer>\n    </fieldType>\n    \n    <!--
    CJK bigram (see text_ja for a Japanese configuration using morphological analysis)
    -->\n    <dynamicField name=\"*_txt_cjk\" type=\"text_cjk\"  indexed=\"true\"
    \ stored=\"true\"/>\n    <fieldType name=\"text_cjk\" class=\"solr.TextField\"
    positionIncrementGap=\"100\">\n      <analyzer>\n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <!-- normalize width before bigram, as e.g. half-width dakuten combine
    \ -->\n        <filter class=\"solr.CJKWidthFilterFactory\"/>\n        <!-- for
    any non-CJK -->\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter
    class=\"solr.CJKBigramFilterFactory\"/>\n      </analyzer>\n    </fieldType>\n\n
    \   <!-- Czech -->\n    <dynamicField name=\"*_txt_cz\" type=\"text_cz\"  indexed=\"true\"
    \ stored=\"true\"/>\n    <fieldType name=\"text_cz\" class=\"solr.TextField\"
    positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_cz.txt\" />\n        <filter class=\"solr.CzechStemFilterFactory\"/>
    \      \n      </analyzer>\n    </fieldType>\n    \n    <!-- Danish -->\n    <dynamicField
    name=\"*_txt_da\" type=\"text_da\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_da\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_da.txt\" format=\"snowball\" />\n        <filter
    class=\"solr.SnowballPorterFilterFactory\" language=\"Danish\"/>       \n      </analyzer>\n
    \   </fieldType>\n    \n    <!-- German -->\n    <dynamicField name=\"*_txt_de\"
    type=\"text_de\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_de\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_de.txt\"
    format=\"snowball\" />\n        <filter class=\"solr.GermanNormalizationFilterFactory\"/>\n
    \       <filter class=\"solr.GermanLightStemFilterFactory\"/>\n        <!-- less
    aggressive: <filter class=\"solr.GermanMinimalStemFilterFactory\"/> -->\n        <!--
    more aggressive: <filter class=\"solr.SnowballPorterFilterFactory\" language=\"German2\"/>
    -->\n      </analyzer>\n    </fieldType>\n    \n    <!-- Greek -->\n    <dynamicField
    name=\"*_txt_el\" type=\"text_el\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_el\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <!-- greek
    specific lowercase for sigma -->\n        <filter class=\"solr.GreekLowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"false\" words=\"lang/stopwords_el.txt\"
    />\n        <filter class=\"solr.GreekStemFilterFactory\"/>\n      </analyzer>\n
    \   </fieldType>\n    \n    <!-- Spanish -->\n    <dynamicField name=\"*_txt_es\"
    type=\"text_es\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_es\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_es.txt\"
    format=\"snowball\" />\n        <filter class=\"solr.SpanishLightStemFilterFactory\"/>\n
    \       <!-- more aggressive: <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Spanish\"/> -->\n      </analyzer>\n    </fieldType>\n    \n    <!--
    Basque -->\n    <dynamicField name=\"*_txt_eu\" type=\"text_eu\"  indexed=\"true\"
    \ stored=\"true\"/>\n    <fieldType name=\"text_eu\" class=\"solr.TextField\"
    positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_eu.txt\" />\n        <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Basque\"/>\n      </analyzer>\n    </fieldType>\n    \n    <!-- Persian
    -->\n    <dynamicField name=\"*_txt_fa\" type=\"text_fa\"  indexed=\"true\"  stored=\"true\"/>\n
    \   <fieldType name=\"text_fa\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n
    \     <analyzer>\n        <!-- for ZWNJ -->\n        <charFilter class=\"solr.PersianCharFilterFactory\"/>\n
    \       <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.ArabicNormalizationFilterFactory\"/>\n
    \       <filter class=\"solr.PersianNormalizationFilterFactory\"/>\n        <filter
    class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_fa.txt\"
    />\n      </analyzer>\n    </fieldType>\n    \n    <!-- Finnish -->\n    <dynamicField
    name=\"*_txt_fi\" type=\"text_fi\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_fi\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_fi.txt\" format=\"snowball\" />\n        <filter
    class=\"solr.SnowballPorterFilterFactory\" language=\"Finnish\"/>\n        <!--
    less aggressive: <filter class=\"solr.FinnishLightStemFilterFactory\"/> -->\n
    \     </analyzer>\n    </fieldType>\n    \n    <!-- French -->\n    <dynamicField
    name=\"*_txt_fr\" type=\"text_fr\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_fr\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <!-- removes
    l', etc -->\n        <filter class=\"solr.ElisionFilterFactory\" ignoreCase=\"true\"
    articles=\"lang/contractions_fr.txt\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_fr.txt\"
    format=\"snowball\" />\n        <filter class=\"solr.FrenchLightStemFilterFactory\"/>\n
    \       <!-- less aggressive: <filter class=\"solr.FrenchMinimalStemFilterFactory\"/>
    -->\n        <!-- more aggressive: <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"French\"/> -->\n      </analyzer>\n    </fieldType>\n    \n    <!--
    Irish -->\n    <dynamicField name=\"*_txt_ga\" type=\"text_ga\"  indexed=\"true\"
    \ stored=\"true\"/>\n    <fieldType name=\"text_ga\" class=\"solr.TextField\"
    positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <!-- removes d', etc -->\n        <filter class=\"solr.ElisionFilterFactory\"
    ignoreCase=\"true\" articles=\"lang/contractions_ga.txt\"/>\n        <!-- removes
    n-, etc. position increments is intentionally false! -->\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/hyphenations_ga.txt\"/>\n        <filter class=\"solr.IrishLowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_ga.txt\"/>\n
    \       <filter class=\"solr.SnowballPorterFilterFactory\" language=\"Irish\"/>\n
    \     </analyzer>\n    </fieldType>\n    \n    <!-- Galician -->\n    <dynamicField
    name=\"*_txt_gl\" type=\"text_gl\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_gl\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_gl.txt\" />\n        <filter class=\"solr.GalicianStemFilterFactory\"/>\n
    \       <!-- less aggressive: <filter class=\"solr.GalicianMinimalStemFilterFactory\"/>
    -->\n      </analyzer>\n    </fieldType>\n    \n    <!-- Hindi -->\n    <dynamicField
    name=\"*_txt_hi\" type=\"text_hi\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_hi\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <!-- normalizes unicode representation
    -->\n        <filter class=\"solr.IndicNormalizationFilterFactory\"/>\n        <!--
    normalizes variation in spelling -->\n        <filter class=\"solr.HindiNormalizationFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_hi.txt\"
    />\n        <filter class=\"solr.HindiStemFilterFactory\"/>\n      </analyzer>\n
    \   </fieldType>\n    \n    <!-- Hungarian -->\n    <dynamicField name=\"*_txt_hu\"
    type=\"text_hu\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_hu\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_hu.txt\"
    format=\"snowball\" />\n        <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Hungarian\"/>\n        <!-- less aggressive: <filter class=\"solr.HungarianLightStemFilterFactory\"/>
    -->   \n      </analyzer>\n    </fieldType>\n    \n    <!-- Armenian -->\n    <dynamicField
    name=\"*_txt_hy\" type=\"text_hy\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_hy\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_hy.txt\" />\n        <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Armenian\"/>\n      </analyzer>\n    </fieldType>\n    \n    <!-- Indonesian
    -->\n    <dynamicField name=\"*_txt_id\" type=\"text_id\"  indexed=\"true\"  stored=\"true\"/>\n
    \   <fieldType name=\"text_id\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n
    \     <analyzer> \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_id.txt\" />\n        <!-- for a less
    aggressive approach (only inflectional suffixes), set stemDerivational to false
    -->\n        <filter class=\"solr.IndonesianStemFilterFactory\" stemDerivational=\"true\"/>\n
    \     </analyzer>\n    </fieldType>\n    \n    <!-- Italian -->\n  <dynamicField
    name=\"*_txt_it\" type=\"text_it\"  indexed=\"true\"  stored=\"true\"/>\n  <fieldType
    name=\"text_it\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <!-- removes
    l', etc -->\n        <filter class=\"solr.ElisionFilterFactory\" ignoreCase=\"true\"
    articles=\"lang/contractions_it.txt\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_it.txt\"
    format=\"snowball\" />\n        <filter class=\"solr.ItalianLightStemFilterFactory\"/>\n
    \       <!-- more aggressive: <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Italian\"/> -->\n      </analyzer>\n    </fieldType>\n    \n    <!--
    Japanese using morphological analysis (see text_cjk for a configuration using
    bigramming)\n\n         NOTE: If you want to optimize search for precision, use
    default operator AND in your request\n         handler config (q.op) Use OR if
    you would like to optimize for recall (default).\n    -->\n    <dynamicField name=\"*_txt_ja\"
    type=\"text_ja\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_ja\"
    class=\"solr.TextField\" positionIncrementGap=\"100\" autoGeneratePhraseQueries=\"false\">\n
    \     <analyzer>\n        <!-- Kuromoji Japanese morphological analyzer/tokenizer
    (JapaneseTokenizer)\n\n           Kuromoji has a search mode (default) that does
    segmentation useful for search.  A heuristic\n           is used to segment compounds
    into its parts and the compound itself is kept as synonym.\n\n           Valid
    values for attribute mode are:\n              normal: regular segmentation\n              search:
    segmentation useful for search with synonyms compounds (default)\n            extended:
    same as search mode, but unigrams unknown words (experimental)\n\n           For
    some applications it might be good to use search mode for indexing and normal
    mode for\n           queries to reduce recall and prevent parts of compounds from
    being matched and highlighted.\n           Use <analyzer type=\"index\"> and <analyzer
    type=\"query\"> for this and mode normal in query.\n\n           Kuromoji also
    has a convenient user dictionary feature that allows overriding the statistical\n
    \          model with your own entries for segmentation, part-of-speech tags and
    readings without a need\n           to specify weights.  Notice that user dictionaries
    have not been subject to extensive testing.\n\n           User dictionary attributes
    are:\n                     userDictionary: user dictionary filename\n             userDictionaryEncoding:
    user dictionary encoding (default is UTF-8)\n\n           See lang/userdict_ja.txt
    for a sample user dictionary file.\n\n           Punctuation characters are discarded
    by default.  Use discardPunctuation=\"false\" to keep them.\n        -->\n        <tokenizer
    class=\"solr.JapaneseTokenizerFactory\" mode=\"search\"/>\n        <!--<tokenizer
    class=\"solr.JapaneseTokenizerFactory\" mode=\"search\" userDictionary=\"lang/userdict_ja.txt\"/>-->\n
    \       <!-- Reduces inflected verbs and adjectives to their base/dictionary forms
    (辞書形) -->\n        <filter class=\"solr.JapaneseBaseFormFilterFactory\"/>\n        <!--
    Removes tokens with certain part-of-speech tags -->\n        <filter class=\"solr.JapanesePartOfSpeechStopFilterFactory\"
    tags=\"lang/stoptags_ja.txt\" />\n        <!-- Normalizes full-width romaji to
    half-width and half-width kana to full-width (Unicode NFKC subset) -->\n        <filter
    class=\"solr.CJKWidthFilterFactory\"/>\n        <!-- Removes common tokens typically
    not useful for search, but have a negative effect on ranking -->\n        <filter
    class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_ja.txt\"
    />\n        <!-- Normalizes common katakana spelling variations by removing any
    last long sound character (U+30FC) -->\n        <filter class=\"solr.JapaneseKatakanaStemFilterFactory\"
    minimumLength=\"4\"/>\n        <!-- Lower-cases romaji characters -->\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n      </analyzer>\n    </fieldType>\n
    \   \n    <!-- Korean morphological analysis -->\n    <dynamicField name=\"*_txt_ko\"
    type=\"text_ko\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_ko\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>\n        <!--
    Nori Korean morphological analyzer/tokenizer (KoreanTokenizer)\n          The
    Korean (nori) analyzer integrates Lucene nori analysis module into Solr.\n          It
    uses the mecab-ko-dic dictionary to perform morphological analysis of Korean texts.\n\n
    \         This dictionary was built with MeCab, it defines a format for the features
    adapted\n          for the Korean language.\n          \n          Nori also has
    a convenient user dictionary feature that allows overriding the statistical\n
    \         model with your own entries for segmentation, part-of-speech tags and
    readings without a need\n          to specify weights. Notice that user dictionaries
    have not been subject to extensive testing.\n\n          The tokenizer supports
    multiple schema attributes:\n            * userDictionary: User dictionary path.\n
    \           * userDictionaryEncoding: User dictionary encoding.\n            *
    decompoundMode: Decompound mode. Either 'none', 'discard', 'mixed'. Default is
    'discard'.\n            * outputUnknownUnigrams: If true outputs unigrams for
    unknown words.\n        -->\n        <tokenizer class=\"solr.KoreanTokenizerFactory\"
    decompoundMode=\"discard\" outputUnknownUnigrams=\"false\"/>\n        <!-- Removes
    some part of speech stuff like EOMI (Pos.E), you can add a parameter 'tags',\n
    \         listing the tags to remove. By default it removes: \n          E, IC,
    J, MAG, MAJ, MM, SP, SSC, SSO, SC, SE, XPN, XSA, XSN, XSV, UNA, NA, VSV\n          This
    is basically an equivalent to stemming.\n        -->\n        <filter class=\"solr.KoreanPartOfSpeechStopFilterFactory\"
    />\n        <!-- Replaces term text with the Hangul transcription of Hanja characters,
    if applicable: -->\n        <filter class=\"solr.KoreanReadingFormFilterFactory\"
    />\n        <filter class=\"solr.LowerCaseFilterFactory\" />\n      </analyzer>\n
    \   </fieldType>\n\n    <!-- Latvian -->\n    <dynamicField name=\"*_txt_lv\"
    type=\"text_lv\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_lv\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_lv.txt\"
    />\n        <filter class=\"solr.LatvianStemFilterFactory\"/>\n      </analyzer>\n
    \   </fieldType>\n    \n    <!-- Dutch -->\n    <dynamicField name=\"*_txt_nl\"
    type=\"text_nl\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType name=\"text_nl\"
    class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer> \n        <tokenizer
    class=\"solr.StandardTokenizerFactory\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_nl.txt\"
    format=\"snowball\" />\n        <filter class=\"solr.StemmerOverrideFilterFactory\"
    dictionary=\"lang/stemdict_nl.txt\" ignoreCase=\"false\"/>\n        <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Dutch\"/>\n      </analyzer>\n    </fieldType>\n    \n    <!-- Norwegian
    -->\n    <dynamicField name=\"*_txt_no\" type=\"text_no\"  indexed=\"true\"  stored=\"true\"/>\n
    \   <fieldType name=\"text_no\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n
    \     <analyzer> \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_no.txt\" format=\"snowball\" />\n        <filter
    class=\"solr.SnowballPorterFilterFactory\" language=\"Norwegian\"/>\n        <!--
    less aggressive: <filter class=\"solr.NorwegianLightStemFilterFactory\"/> -->\n
    \       <!-- singular/plural: <filter class=\"solr.NorwegianMinimalStemFilterFactory\"/>
    -->\n      </analyzer>\n    </fieldType>\n    \n    <!-- Portuguese -->\n  <dynamicField
    name=\"*_txt_pt\" type=\"text_pt\"  indexed=\"true\"  stored=\"true\"/>\n  <fieldType
    name=\"text_pt\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_pt.txt\" format=\"snowball\" />\n        <filter
    class=\"solr.PortugueseLightStemFilterFactory\"/>\n        <!-- less aggressive:
    <filter class=\"solr.PortugueseMinimalStemFilterFactory\"/> -->\n        <!--
    more aggressive: <filter class=\"solr.SnowballPorterFilterFactory\" language=\"Portuguese\"/>
    -->\n        <!-- most aggressive: <filter class=\"solr.PortugueseStemFilterFactory\"/>
    -->\n      </analyzer>\n    </fieldType>\n    \n    <!-- Romanian -->\n    <dynamicField
    name=\"*_txt_ro\" type=\"text_ro\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_ro\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_ro.txt\" />\n        <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Romanian\"/>\n      </analyzer>\n    </fieldType>\n    \n    <!-- Russian
    -->\n    <dynamicField name=\"*_txt_ru\" type=\"text_ru\"  indexed=\"true\"  stored=\"true\"/>\n
    \   <fieldType name=\"text_ru\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n
    \     <analyzer> \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n
    \       <filter class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_ru.txt\" format=\"snowball\" />\n        <filter
    class=\"solr.SnowballPorterFilterFactory\" language=\"Russian\"/>\n        <!--
    less aggressive: <filter class=\"solr.RussianLightStemFilterFactory\"/> -->\n
    \     </analyzer>\n    </fieldType>\n    \n    <!-- Swedish -->\n    <dynamicField
    name=\"*_txt_sv\" type=\"text_sv\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_sv\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.LowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"true\" words=\"lang/stopwords_sv.txt\" format=\"snowball\" />\n        <filter
    class=\"solr.SnowballPorterFilterFactory\" language=\"Swedish\"/>\n        <!--
    less aggressive: <filter class=\"solr.SwedishLightStemFilterFactory\"/> -->\n
    \     </analyzer>\n    </fieldType>\n    \n    <!-- Thai -->\n    <dynamicField
    name=\"*_txt_th\" type=\"text_th\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_th\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>\n
    \       <tokenizer class=\"solr.ThaiTokenizerFactory\"/>\n        <filter class=\"solr.LowerCaseFilterFactory\"/>\n
    \       <filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"lang/stopwords_th.txt\"
    />\n      </analyzer>\n    </fieldType>\n    \n    <!-- Turkish -->\n    <dynamicField
    name=\"*_txt_tr\" type=\"text_tr\"  indexed=\"true\"  stored=\"true\"/>\n    <fieldType
    name=\"text_tr\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer>
    \n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter
    class=\"solr.TurkishLowerCaseFilterFactory\"/>\n        <filter class=\"solr.StopFilterFactory\"
    ignoreCase=\"false\" words=\"lang/stopwords_tr.txt\" />\n        <filter class=\"solr.SnowballPorterFilterFactory\"
    language=\"Turkish\"/>\n      </analyzer>\n    </fieldType>\n\n    <!-- Similarity
    is the scoring routine for each document vs. a query.\n       A custom Similarity
    or SimilarityFactory may be specified here, but \n       the default is fine for
    most applications.  \n       For more info: http://lucene.apache.org/solr/guide/other-schema-elements.html#OtherSchemaElements-Similarity\n
    \   -->\n    <!--\n     <similarity class=\"com.example.solr.CustomSimilarityFactory\">\n
    \      <str name=\"paramkey\">param value</str>\n     </similarity>\n    -->\n\n</schema>\n"
kind: ConfigMap
metadata:
  name: managed-schema
  namespace: utility
